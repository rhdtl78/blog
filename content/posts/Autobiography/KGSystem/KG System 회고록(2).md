---
template: post
title: "KG System 회고록 (2)"
date: "2020-04-07T01:00:00+09:00Z"
slug: /posts/autobiography/kgsystem/2
category: Autobiography
description: "2번째 실무!"
tags: 
  - Autobiography
  - KGSystem
priority: 0
---
![KG System Logo](/companies/kgsystem.png)

[KG System 홈페이지](https://kgsystem.co.kr)

### 다시 출근
이전의 파트타임 이후, 학기를 마친 나는 다시 파트타임으로 채용되었다.
2018.01 ~ 2018.02, 최저 시급으로 일할 수 있으며 본격 적으로 배운 것을 써먹으려 했다.
이 당시 나는 웹 프로그래밍을 막 이수한 상태였고, 드디어 뭔가 제대로 하겠구나 라는 생각으로 들떠있었다.

저번 과는 달리, 컴퓨터와 자리를 배정 받아 셋업 할 수 있었다.
Windows 환경, Autoset으로 개발 환경을 서비스 할 수 있게 설정, PHP, Visual Studio Code, git으로 설정을 마치고, 업무 분담을 위해 미팅도 가졌다.

내가 맡은 업무는 다음과 같았다.
- 사이트 리뉴얼을 위한 Repository 설정
- Jenkins로 자동 배포 설정
- 하네스표 관리 페이지 (2017년도 결과물) 이전 및 데이터 이전
- 생산관리 기능을 제외한 다른 기능들 이전 및 Bootstrap4 적용
- SPA (Single Page Application)으로 동작

---

### 기술 Stack 선정
기존의 사이트는 지인이 독학으로 구축하여 데이터 요청 로직과 뷰가 혼재되어있는 스파게티 코드가 대부분이었고, 라우팅은 디렉토리로 하고있었다. SPA로 구축하길 원했었고 이를 위한 라우팅 방식도 필요했다.

이에 나는 아예 언어를 바꾸고 Framework 도입을 생각하는게 어떻겠는가 제안을 했고, 테스트 개발을 진행했다.
채택된 사양은 아래와 같다.
- node
- express
- mongoose
- mongodb
- pug + jquery

직전 학기 웹 프로그래밍 수업에서 사용한 Stack을 그대로 빌려와서 진행해보려 했다. 그러나 여기서 문제가 발생했다.
본인은 당연히 학습한지 오래 지나지 않아서 금방 결과물을 볼수 있었으나, 
금방 따라갈 수 있을 것이라 예상했지만, pug와 node에 적응하지 못했다. 
물론 시간만 있다면야 배워서 써먹으면 되겠지만, 현실은 정해진 시간 내에 결과물을 만들어내야 하기 때문에 그럴 수 없었다.

결국 stack은 다시 php로 회귀되었다.

---

### 리뉴얼 시작
라우팅 문제는 나중에 해결하기로 하고 일단 작업에 착수하였다.
2017년도에 내가 개발한 기능 (하네스표)를 옮기는 것은 문제되지 않았다. 
목록을 별도로 구성해 iframe으로 불러오는 방식을 php로 파편화해서 SPA로 동작하게 변경했고
기존의 데이터 다루는 부분은 그대로 옮겨 적용했다.

일이 금방 진행되어 방학 동안에 금방 할 수 있을 것으로 생각했었다.

그러나 그건 오산이었다.

다른 기능들이 앞서 말한대로 스파게티 코드란 것을 잊고있었다.

루프 내 쿼리 질의가 있었고, 동시에 필터링도 있었고, 동시에 마크업도 있었다.
분석이 우선이었고, 사용중인 기능에 문제가 없어야 했다.

그래서 우선 마크업을 별도로 정리하기로 했다.

루프 내에 있는 마크업, 분기 별로 다르게 나와야 하는 마크업을 주석으로 표시하고, 
데이터 색인부분을 다시 파일 상단으로 올려 변수에 저장하게 변경했다.

이후 <?php foreach(): ?> 같은 문법으로 마크업을 정리하고 기능을 테스트했다.

당연히 당시엔 TDD도 몰랐으니 모든 테스트는 직접 사용해보는 것으로 진행했다.

굉장히 오래걸리고 지루한 작업이었지만, 스파게티가 다시 정돈된 재료로 돌아가는 것을 보니 견딜만 했다.

---

### 이건 또 무슨 에러? (이벤트 중복)
작업하며 격은 에러중에 가장 기억에 남았던 것은 이벤트가 남아있어 페이지가 오작동하는 것이었다.
jQuery를 사용하며 생길 수 있는 흔한 에러였지만, 기본 지식이 부족했던 상태라 찾는데 애먹었다.

페이지 전환을 발생하게하는 버튼을 예로 들어보자.

```javascript
$('#activity-changer').click(e => {
  e.stopPropagation();
  $.ajax({ /* 페이지 리소스 요청 설정 */})
    .then((response) => {
        $('#content').html(response)
    })
    .catch(() => { /* 에러 핸들링 */ })
});
```

이벤트 전파도 막고, 비동기 문제도 해결하고, 에러 핸들링도 했다.
문제가 없을 것이라고 생각하고 다른 페이지의 코드 조각에도 같은 코드를 작성했다.

이때 문제가 생겼다. 
activity-changer라는 id 버튼 엘리먼트를 그대로 사용했다.
당시 생각엔 이전의 이벤트 핸들러를 덮어 쓸 것이라 생각했지만 큰 착각이었다.

```javascript
/// a.php
$('#activity-changer').click(...)
/// b.php
$('#activity-changer').click(...)
```

이렇게 b.php의 버튼은 b.php의 핸들러만 수행해야 하지만, a.php의 핸들러가 없어지지 않은 상태로 클릭 이벤트를 처리하게 되었다.
그래서 사용자가 원하는 페이지로 전환되는 것이 아닌, 이전의 페이지에서 선언한 로직이 실행되는 오작동을 한 것이다. 

이후 해당 에러의 원인과 해결방법을 찾았다.
주로 동적 생성된 엘리먼트의 이벤트 바인딩에서 자주 발생하는 실수임을 알았고, 이를 해결하는 방법은 해당 이벤트를 언바인드 하는 것임을 알게 되었다.
```javascript
$('#activity-changer').off('click');
$('#activity-changer').click(...)
```

$.off 로 더 이상 클릭 이벤트가 중복되게 바인드되는 현상은 없어졌다.

조금 더 깊이 찾아보니 [D2에 정리된 글](https://d2.naver.com/helloworld/1855209)을 찾을 수 있었다.

아래 4가지는 위에 정리된 글의 마무리를 가져온 것이다.
1. 실제 DOM 요소에 등록되는 이벤트 핸들러는 사용자가 정의한 이벤트 핸들러가 아니라 jQuery의 이벤트 핸들러다.
2. 같은 이벤트에 이벤트 핸들러를 여러 번 등록해도 처음 한 번만 실제로 등록되고 나머지는 내부에서 큐 형태로 관리된다.
3. 요소에 설정되는 이벤트 정보는 내부 캐시에 저장된다.
4. special 이벤트 훅을 사용하면 특점 시점에 이벤트를 제어할 수 있다.

### 마무리
이렇게 내가 배운 것을 여러 방면으로 시험해보며 방학이 끝나고 나는 다시 복학했다.
이때 배운 것 덕분에 2018년도 여름학기 팀프로젝트에서 웹 분야의 담당으로 참여할 수 있었다.
