<!doctype html>
<html lang="en" dir="ltr" class="blog-wrapper blog-post-page plugin-blog plugin-id-default">
<head>
<meta charset="UTF-8">
<meta name="generator" content="Docusaurus v2.4.1">
<title data-rh="true">[오브젝트] Chapter02. 객체지향 프로그래밍. | Jeonghun Kong&#x27;s Devlog</title><meta data-rh="true" name="viewport" content="width=device-width,initial-scale=1"><meta data-rh="true" name="twitter:card" content="summary_large_image"><meta data-rh="true" property="og:url" content="https://rhdtl78.github.io/dev-blog/object/chapter/02"><meta data-rh="true" name="docusaurus_locale" content="en"><meta data-rh="true" name="docusaurus_tag" content="default"><meta data-rh="true" name="docsearch:language" content="en"><meta data-rh="true" name="docsearch:docusaurus_tag" content="default"><meta data-rh="true" property="og:title" content="[오브젝트] Chapter02. 객체지향 프로그래밍. | Jeonghun Kong&#x27;s Devlog"><meta data-rh="true" name="description" content="객체지향 프로그래밍"><meta data-rh="true" property="og:description" content="객체지향 프로그래밍"><meta data-rh="true" property="og:type" content="article"><meta data-rh="true" property="article:published_time" content="2021-01-11T00:00:00.000Z"><meta data-rh="true" property="article:tag" content="Object,Book Study,OOP"><link data-rh="true" rel="icon" href="/img/favicon.ico"><link data-rh="true" rel="canonical" href="https://rhdtl78.github.io/dev-blog/object/chapter/02"><link data-rh="true" rel="alternate" href="https://rhdtl78.github.io/dev-blog/object/chapter/02" hreflang="en"><link data-rh="true" rel="alternate" href="https://rhdtl78.github.io/dev-blog/object/chapter/02" hreflang="x-default"><link rel="alternate" type="application/rss+xml" href="/rss.xml" title="Jeonghun Kong&#39;s Devlog RSS Feed">
<link rel="alternate" type="application/atom+xml" href="/atom.xml" title="Jeonghun Kong&#39;s Devlog Atom Feed">




<link rel="alternate" type="application/rss+xml" href="/blog/rss.xml" title="Jeonghun Kong&#39;s Devlog RSS Feed">
<link rel="alternate" type="application/atom+xml" href="/blog/atom.xml" title="Jeonghun Kong&#39;s Devlog Atom Feed"><link rel="stylesheet" href="/assets/css/styles.4bd2c844.css">
<link rel="preload" href="/assets/js/runtime~main.989dd6bd.js" as="script">
<link rel="preload" href="/assets/js/main.044671ee.js" as="script">
</head>
<body class="navigation-with-keyboard">
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){var t=null;try{t=new URLSearchParams(window.location.search).get("docusaurus-theme")}catch(t){}return t}()||function(){var t=null;try{t=localStorage.getItem("theme")}catch(t){}return t}();t(null!==e?e:"light")}()</script><div id="__docusaurus">
<div role="region" aria-label="Skip to main content"><a class="skipToContent_fXgn" href="#__docusaurus_skipToContent_fallback">Skip to main content</a></div><nav aria-label="Main" class="navbar navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><button aria-label="Toggle navigation bar" aria-expanded="false" class="navbar__toggle clean-btn" type="button"><svg width="30" height="30" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/"><div class="navbar__logo"><img src="https://github.com/rhdtl78.png" alt="Devlog Logo" class="themedImage_ToTc themedImage--light_HNdA"><img src="https://github.com/rhdtl78.png" alt="Devlog Logo" class="themedImage_ToTc themedImage--dark_i4oU"></div><b class="navbar__title text--truncate">Devlog</b></a><a class="navbar__item navbar__link" href="/blog">Blog</a><a class="navbar__item navbar__link" href="/cv">CV</a></div><div class="navbar__items navbar__items--right"><a href="https://github.com/rhdtl78" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link">GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a><div class="toggle_vylO colorModeToggle_DEke"><button class="clean-btn toggleButton_gllP toggleButtonDisabled_aARS" type="button" disabled="" title="Switch between dark and light mode (currently light mode)" aria-label="Switch between dark and light mode (currently light mode)" aria-live="polite"><svg viewBox="0 0 24 24" width="24" height="24" class="lightToggleIcon_pyhR"><path fill="currentColor" d="M12,9c1.65,0,3,1.35,3,3s-1.35,3-3,3s-3-1.35-3-3S10.35,9,12,9 M12,7c-2.76,0-5,2.24-5,5s2.24,5,5,5s5-2.24,5-5 S14.76,7,12,7L12,7z M2,13l2,0c0.55,0,1-0.45,1-1s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S1.45,13,2,13z M20,13l2,0c0.55,0,1-0.45,1-1 s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S19.45,13,20,13z M11,2v2c0,0.55,0.45,1,1,1s1-0.45,1-1V2c0-0.55-0.45-1-1-1S11,1.45,11,2z M11,20v2c0,0.55,0.45,1,1,1s1-0.45,1-1v-2c0-0.55-0.45-1-1-1C11.45,19,11,19.45,11,20z M5.99,4.58c-0.39-0.39-1.03-0.39-1.41,0 c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0s0.39-1.03,0-1.41L5.99,4.58z M18.36,16.95 c-0.39-0.39-1.03-0.39-1.41,0c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0c0.39-0.39,0.39-1.03,0-1.41 L18.36,16.95z M19.42,5.99c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06c-0.39,0.39-0.39,1.03,0,1.41 s1.03,0.39,1.41,0L19.42,5.99z M7.05,18.36c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06 c-0.39,0.39-0.39,1.03,0,1.41s1.03,0.39,1.41,0L7.05,18.36z"></path></svg><svg viewBox="0 0 24 24" width="24" height="24" class="darkToggleIcon_wfgR"><path fill="currentColor" d="M9.37,5.51C9.19,6.15,9.1,6.82,9.1,7.5c0,4.08,3.32,7.4,7.4,7.4c0.68,0,1.35-0.09,1.99-0.27C17.45,17.19,14.93,19,12,19 c-3.86,0-7-3.14-7-7C5,9.07,6.81,6.55,9.37,5.51z M12,3c-4.97,0-9,4.03-9,9s4.03,9,9,9s9-4.03,9-9c0-0.46-0.04-0.92-0.1-1.36 c-0.98,1.37-2.58,2.26-4.4,2.26c-2.98,0-5.4-2.42-5.4-5.4c0-1.81,0.89-3.42,2.26-4.4C12.92,3.04,12.46,3,12,3L12,3z"></path></svg></button></div><div class="searchBox_ZlJk"></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div></nav><div id="__docusaurus_skipToContent_fallback" class="main-wrapper mainWrapper_z2l0"><div class="container margin-vert--lg"><div class="row"><aside class="col col--3"><nav class="sidebar_re4s thin-scrollbar" aria-label="Blog recent posts navigation"><div class="sidebarItemTitle_pO2u margin-bottom--md">Recent posts</div><ul class="sidebarItemList_Yudw clean-list"><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/dev-blog/programming/acl-with-aop">Access Control with AOP</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/dev-blog/object/chapter/09">[오브젝트] Chapter09. 유연한 설계</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/dev-blog/object/chapter/07">[오브젝트] Chapter07. 객체 분해</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/dev-blog/object/chapter/06">[오브젝트] Chapter06. 메시지와 인터페이스</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/dev-blog/object/chapter/05">[오브젝트] Chapter05. 책임 할당하기. - GRASP Pattern</a></li></ul></nav></aside><main class="col col--7" itemscope="" itemtype="http://schema.org/Blog"><article itemprop="blogPost" itemscope="" itemtype="http://schema.org/BlogPosting"><header><h1 class="title_f1Hy" itemprop="headline">[오브젝트] Chapter02. 객체지향 프로그래밍.</h1><div class="container_mt6G margin-vert--md"><time datetime="2021-01-11T00:00:00.000Z" itemprop="datePublished">January 11, 2021</time> · <!-- -->17 min read</div></header><div id="__blog-post-container" class="markdown" itemprop="articleBody"><h2 class="anchor anchorWithStickyNavbar_LWe7" id="요구사항-확인">요구사항 확인<a href="#요구사항-확인" class="hash-link" aria-label="Direct link to 요구사항 확인" title="Direct link to 요구사항 확인">​</a></h2><p>모든 설계가 그러하듯 요구사항을 확인하는 것이 우선이다. 요구사항 분석을 통해 필요한 객체를 정할 수 있고, 각 객체의 책임을 어떻게 분배할지 방향을 잡을 수 있다.  </p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="협력-객체-클래스">협력, 객체, 클래스<a href="#협력-객체-클래스" class="hash-link" aria-label="Direct link to 협력, 객체, 클래스" title="Direct link to 협력, 객체, 클래스">​</a></h2><p>보통 프로그래밍을 어떻게 하는지 생각해보자. 객체지향으로 프로그래밍을 한다고 했을때 가장 먼저 하는것이 무엇인가?  대부분 어떤 <strong>class</strong> 가 필요할 지 고민한다.<br>
<!-- -->클래스를 먼저 고민하고, 각 클래스는 어떤 속성과 메서드를 가지고 있어야 할 지를 생각한다.   </p><p>객체지향 프로그래밍을 위해서는 우선 클래스가 아닌 <strong>객체</strong> 에 초점을 맞춰야 한다.  </p><ol><li>어떤 클래스가 필요한 지가 아닌, 어떤 객체가 필요한지를 생각한다.<br>클래스는 공통적인 상태와 행동을 공유하는 객체를 추상화 한것이다. 추상화를 하기 위한 개념을 먼저 정리해야한다.</li><li>객체를 독립적인 존재가 아니라 기능을 구현하기위해 협력하는 공동체의 구성원으로 봐야한다.<br>객체는 혼자서 할 수 있는 일은 거의 없다. 다른 객체와 상호작용하며 서로 협력하는 존재이며 살아 움직이는 생명체로서 봐야한다. </li></ol><h2 class="anchor anchorWithStickyNavbar_LWe7" id="도메인의-구조를-따르는-프로그램-구조">도메인의 구조를 따르는 프로그램 구조<a href="#도메인의-구조를-따르는-프로그램-구조" class="hash-link" aria-label="Direct link to 도메인의 구조를 따르는 프로그램 구조" title="Direct link to 도메인의 구조를 따르는 프로그램 구조">​</a></h2><h3 class="anchor anchorWithStickyNavbar_LWe7" id="도메인">도메인?<a href="#도메인" class="hash-link" aria-label="Direct link to 도메인?" title="Direct link to 도메인?">​</a></h3><p>도메인이란 문제를 해결하기 위해 사용자가 프로그램을 사용하는 분야라 할수 있다. 영화 예매 시스템을 예로 들면, 영화를 좀 더 쉽고 빠르게 예매하려는 사용자의 문제를 해결 하는 것이다.<br>
<!-- -->여기서 도메인은 영화 예매라 할 수 있다. 도메인은 이처럼 문제를 다루는 범위로 볼 수 있으며 더 작은 단위로도 생각해 볼 수 있다. </p><p>자바와 같은 객체지향 언어를 사용하면 이런 도메인이 class로 이어진다는 것을 쉽게 볼 수 있다. 클래스의 이름은 도메인을 쉽게 유추할 수 있는 이름으로 해야 하고 클래스 간의 관계 또한 도메인의 관계가 반영되어야 한다.  </p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="클래스-구현">클래스 구현<a href="#클래스-구현" class="hash-link" aria-label="Direct link to 클래스 구현" title="Direct link to 클래스 구현">​</a></h2><p>도메인의 정의 다음으로 해야할 일은 도메인을 반영하는 클래스를 구현하는 것이다. 이때, 클래스 외부와 내부의 경계를 구분지어 명확한 경계를 세워야한다. 클래스를 구현하거나 다른 개발자에 의해 개발된 클래슬ㄹ 사용할 때 가장 중요한 것은 클래스의 경계를 구분짓는 것이다.<br>
<!-- -->이 경계가 명확할 수록 객체의 자율성이 보장된다 (chapter 01 참고). 또한 프로그래머에게 구현의 자유를 제공하기 때문에 경계를 명확히 해야 한다. </p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="자율적인-객체">자율적인 객체<a href="#자율적인-객체" class="hash-link" aria-label="Direct link to 자율적인 객체" title="Direct link to 자율적인 객체">​</a></h3><p>객체에 대해 명심해야할 두 가지 사실이 있다. </p><ol><li>객체는 상태 (state)와 행동 (behavior)ㅇㅇ 함께 가지는 복합적인 존재이다. </li><li>객체는 스스로 판단하고 행동하는 자율적인 존재이다.</li></ol><p>객체 지향 개념은 객체라는 단위 안에 데이터와 기능을 한 덩어리로 묶음으로서 문제 영역의 아이디어를 적절하게 표현할 수 있게한다 (캡슐화).
객체 내부에 대한 접근을 통제하는 이유는 객체를 자율적인 존재로 만들기 위해서이다. 객체 외부의 그 무엇도 객체 내부의 상태에 직접 간섭해서는 안되며 객체가 어떤 생각을 하는지도 알아선 안된다.</p><p>객체의 캡슐화와 접근제어는 2가지로 나뉜다.</p><ol><li>public interface (퍼블릭 인터페이스)
외부에서 접근 가능한 부분이며 메시지 교환을 위해 외부에 노출하는 부분이다.</li><li>implementation (구현)
외부에서는 접근 불가능하고 오직 내부에서만 접근 가능한 부분이다. </li></ol><p>이는 인터페이스와 구현의 분리 원칙으로 훌륭한 객체지향 프로그램의 원칙 중 하나이다. 일반적으로 객체의 상탠ㄴ 숨기고 행동만 외부에 공개해야 한다. 속성은 private로 감추고 메서드는 public으로 공개하는 식이다. </p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="프로그래머의-자유">프로그래머의 자유<a href="#프로그래머의-자유" class="hash-link" aria-label="Direct link to 프로그래머의 자유" title="Direct link to 프로그래머의 자유">​</a></h3><blockquote><p>프로그래머의 역할을 클래스 작성자와 클라이언트 프로그래머로 구분하는 것이 유용하다 <!-- -->[Eckel06]<!-- -->.</p></blockquote><p>클래스 작성자는 새로운 데이터 타입을 추가하고, 클라이언트 프로그래머는 클래스 작성자가 추가한 데이터 타입을 사용한다.<br>
<!-- -->클래스 작성자는 클라이언트 프로그래머가 접근하면 안되는 곳을 접근 제한을 통해 구현 은닉(implementation hiding)을 통해 제한한다. 이를 통해 클래스 작성자는 클라이언트 프로그래머에게 미칠 영향으로부터 자유롭게 내부 구현을 변경할 수 있다.<br>
<!-- -->이 구현 은닉은 양쪽에게 이로운 개념이다. 클라이언트 프그래머는 내부 구현은 무시한 채 공개 인터페이스만 알고 있으면 된다. 클래스 작성자는 외부에 미칠 영향을 걱정하지 않고 변경을 할 수 있다.</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="협력하는-객체들의-공동체">협력하는 객체들의 공동체<a href="#협력하는-객체들의-공동체" class="hash-link" aria-label="Direct link to 협력하는 객체들의 공동체" title="Direct link to 협력하는 객체들의 공동체">​</a></h2><p>앞서 말했듯 객체들은 서로 협력하며 존재한다. 객체는 다른 객체의 인터페잇에 공개된 행동을 수행하도록 요청할 수 있다. 요청을 받은 객체는 자율적인 방법에 따라 요청을 처리한 후 응답한다.<br>
<!-- -->객체가 받은 요청을 처리하기 위한 방법을 메서드라고 한다.</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="추상화---상속과-다형성">추상화 - 상속과 다형성<a href="#추상화---상속과-다형성" class="hash-link" aria-label="Direct link to 추상화 - 상속과 다형성" title="Direct link to 추상화 - 상속과 다형성">​</a></h2><h3 class="anchor anchorWithStickyNavbar_LWe7" id="컴파일-시간-의존성과-실행시간-의존성">컴파일 시간 의존성과 실행시간 의존성<a href="#컴파일-시간-의존성과-실행시간-의존성" class="hash-link" aria-label="Direct link to 컴파일 시간 의존성과 실행시간 의존성" title="Direct link to 컴파일 시간 의존성과 실행시간 의존성">​</a></h3><p>코드의 의존성과 실행 시점의 의존성이 서로 다를 수 있다. 유연하고 쉽게 재사용 할 수 있으며 확장 가능한 설계가 된다.<br>
<!-- -->그러나 이렇게 유연해 질 수록 복잡도는 높아진다. 실행시점과 컴파일 시점의 의존성이 달라지면 코드를 이해하기 어려워진다. (Trade off :: 유연성, 재사용성 vs 유지보수)</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="차이에-의한-프로그래밍">차이에 의한 프로그래밍<a href="#차이에-의한-프로그래밍" class="hash-link" aria-label="Direct link to 차이에 의한 프로그래밍" title="Direct link to 차이에 의한 프로그래밍">​</a></h3><p>상속은 코드를 재사용하기 위해 가장 널리 사용되는 방법이다. 부모의 코드를 그대로 자식에게 물려줄 수 있으며 자식은 부모와 다른 부분만을 구현하면 쉽게 확장할 수 있다. 이런 방식을 차이에 의한 프로그래밍이라 한다.</p><p>상속이 가치있는 이유는 부모의 변수를 재활용하기 때문이라기 보다는 부모가 가진 모든 인터페이스를 자식 클래스가 물려 받을 수 있기 때문이다. 인터페이스는 객체가 이해할 수 있는 메시지의 목록을 정의하는 것임을 생각하면 알수 있다.<br>
<!-- -->실제로 객체간의 관계에서 중요한 것은 어떤 인스턴스인지가 아니라 어떤 메시지를 수신할 수 있느냐가 중요한 것이다. </p><p>런타임에서 자식은 부모의 모든 메시지를 수신 할 수 있기에 부모 클래스와 같은 타입으로 취급하기도 한다. 이를 업캐스팅이라 하는데 자식 클래스가 부모의 타입으로 자동 형변환이 되는 것을 말한다. </p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="다형성">다형성<a href="#다형성" class="hash-link" aria-label="Direct link to 다형성" title="Direct link to 다형성">​</a></h3><p>메서드와 메시지는 다른 개념임을 상기하자. 객체가 메시지를 수신하면 어떤 메서드를 실행할 지는 그 객체와 연결된 클래스가 무엇인가에 따라 달라진다.<br>
<!-- -->다시 말해 동일한 메시지에 대해 어떤 메서드가 실행될 것인지는 메시지를 수신하는 객체의 클래스가 무엇이냐에 따라 달라진다. 이를 다형성이라 부른다.</p><p>학부 과정을 이수했다면 들어봤을 동적바인딩, 정적바인딩이 여기서 사용된다. 다형성을 구현하는 방식은 다양하지만 메시지와 메서드를 실행 시점에 연결한다는 것은 동일하다.<br>
<!-- -->이때 컴파일 타임에 연결하게되면 정적 바인딩, 실행 시점에 연결하는 것을 동적 바인딩이라 한다. </p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="인터페이스와-다형성">인터페이스와 다형성<a href="#인터페이스와-다형성" class="hash-link" aria-label="Direct link to 인터페이스와 다형성" title="Direct link to 인터페이스와 다형성">​</a></h3><p>자바 프로그래머에게 친숙한 인터페이스는 이러한 다형성을 위해 제공된 프로그래밍 요소이다. 클래스의 구현은 필요없고 순수하게 인터페이스 만을 공유하고 싶을때 사용한다.
기본적으로는 Abstract Base Class로 인터페이스를 정의할 수 있다. </p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="추상화와-유연성">추상화와 유연성<a href="#추상화와-유연성" class="hash-link" aria-label="Direct link to 추상화와 유연성" title="Direct link to 추상화와 유연성">​</a></h2><h3 class="anchor anchorWithStickyNavbar_LWe7" id="추상화의-힘">추상화의 힘<a href="#추상화의-힘" class="hash-link" aria-label="Direct link to 추상화의 힘" title="Direct link to 추상화의 힘">​</a></h3><p>추상화는 크게 2가지의 장점을 갖고있다. </p><ol><li>추상화 계층만 보면 요구 사항에 대해 높은 수준에서 서술할 수 있다.<br>세부적인 정책을 무시한 채 상위 정책을 쉽고 간단하게 표현할 수 있다. 이는 다른 요소를 배제하고 상위 개념만으로 도메인의 중요 개념을 설명할 수 있게 해준다. </li><li>추상화를 이용하면 설계가 유연해진다.<br>상위 정책을 추상화를 통해 표현하면 구조를 수정핮지 않고 새로운 기능을 쉽게 추가하고 확장할 수 있다. </li></ol><h3 class="anchor anchorWithStickyNavbar_LWe7" id="유연한-설계">유연한 설계<a href="#유연한-설계" class="hash-link" aria-label="Direct link to 유연한 설계" title="Direct link to 유연한 설계">​</a></h3><p>추상화가 유연한 설계를 가능하게 하는 이유는 설계가 구체적인 상황에 결합되는 것을 방지하기 때문이다. 세부 정책을 구현한 클래스가 추상화된 상위 정책을 상속받고 있다면 어떤 클래스와도 협력 가능하다.  </p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="추상-클래스와-인터페이스-트레이드-오프">추상 클래스와 인터페이스 트레이드 오프<a href="#추상-클래스와-인터페이스-트레이드-오프" class="hash-link" aria-label="Direct link to 추상 클래스와 인터페이스 트레이드 오프" title="Direct link to 추상 클래스와 인터페이스 트레이드 오프">​</a></h3><p>구현과 관련된 모든 것들은 트레이드 오프의 대상이 될 수 있다. 코드의 작성에 있어 이유가 없는 코드는 없어야 한다. 사소한 결정이라도 심사숙고한 끝에 나온 코드와 그렇지 않은 코드는 품질에서 큰 차이가 있다.  </p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="코드-재사용">코드 재사용<a href="#코드-재사용" class="hash-link" aria-label="Direct link to 코드 재사용" title="Direct link to 코드 재사용">​</a></h3><p>상속은 일반적으로 코드를 재사용하는데 널리 쓰이는 방법이다. 그러나 널리 사용된다고 해서 베스트는 아니다. 합성(composition)도 들어 보았을 것이다. 사용하고자 하는 코드를 담고있는 인스턴스를 변수로 포함해 사용하는 방식이다.<br>
<!-- -->많은 컨텍스트나 프레임워크들이 합성을 선호하는 모습을 보인다., Spring framework애서도 대부분의 의존성을 합성 관계로 사용하는 것을 볼 수 있다. </p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="상속">상속<a href="#상속" class="hash-link" aria-label="Direct link to 상속" title="Direct link to 상속">​</a></h3><p>왜 상속 대신 합성을 선호할까? 상속의 문제점은 캡슐화를 위반한다는 것과 설계를 유현하지 않게 한다는 것이다.<br>
<!-- -->가장 큰 문제는 캡슐화를 위반한다는 것이다. 상속을 하기 위한 기본 전제는 부모 클래스를 잘 알고있어야 한다는 것이다. 부모 내부의 다른 메서드가 내부의 어떤 추상 메서드를 호출하고 있다는 것을 알고 이를 구현해야 한다.<br>
<!-- -->결과적으로 자식에게 부모의 구현이 고스란히 노출되기 때문에 캡슐화가 약화된다. 부모가 변경된 경우 자식도 변경될 확률을 높인다.</p><p>설계가 유연하지 않게 되는 것은 부모와 자식의 관계가 강하게 결합되기 때문이다. 부모와 자식의 관계는 컴파일 시점에 결정되기 때문에 실행 시점에 객체의 종류를 변경할 수 없게된다. </p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="합성">합성<a href="#합성" class="hash-link" aria-label="Direct link to 합성" title="Direct link to 합성">​</a></h3><p>앞서 말했듯 합성은 인스턴스를 내부에 포함하는 방법으로, 객체의 인스턴스를 통해서만 코드를 재사용할 수 있다. 합성은 상속이 가지는 두가지 문제점을 모두 해결한다.<br>
<!-- -->인터페이스에 정의된 메시지만을 사용하기 때문에 구현을 효과적으로 캡슐화할 수 있다. 또한 의존하는 클래스를 교체하기 쉽기 때문에 설계를 유연하게 만든다.
따라서 코드 재사용을 위해서는 상속 보다는 합성을 선호하는 것이 더 좋은 방법이다. </p><p>그러나 합성만을 사용하는 것은 좋은 방법이 아니다. 대부분의 설계는 상속과 합성을 함께 사용해야 한다. 다형성을 위해 인터페이스를 재사용하는 경우에는 상속과 합성을 함께 조합해서 사용할 수밖에 없다.</p></div><footer class="row docusaurus-mt-lg blogPostFooterDetailsFull_mRVl"><div class="col"><b>Tags:</b><ul class="tags_jXut padding--none margin-left--sm"><li class="tag_QGVx"><a class="tag_zVej tagRegular_sFm0" href="/tags/object">Object</a></li><li class="tag_QGVx"><a class="tag_zVej tagRegular_sFm0" href="/tags/book-study">Book Study</a></li><li class="tag_QGVx"><a class="tag_zVej tagRegular_sFm0" href="/tags/oop">OOP</a></li></ul></div><div class="col margin-top--sm"><a href="https://rhdtl78.github.io/dev-blog/2021-01-11-object-chapter-02-Object-oriented-programming.md" target="_blank" rel="noreferrer noopener" class="theme-edit-this-page"><svg fill="currentColor" height="20" width="20" viewBox="0 0 40 40" class="iconEdit_Z9Sw" aria-hidden="true"><g><path d="m34.5 11.7l-3 3.1-6.3-6.3 3.1-3q0.5-0.5 1.2-0.5t1.1 0.5l3.9 3.9q0.5 0.4 0.5 1.1t-0.5 1.2z m-29.5 17.1l18.4-18.5 6.3 6.3-18.4 18.4h-6.3v-6.2z"></path></g></svg>Edit this page</a></div></footer></article><nav class="pagination-nav docusaurus-mt-lg" aria-label="Blog post page navigation"><a class="pagination-nav__link pagination-nav__link--prev" href="/dev-blog/object/chapter/03"><div class="pagination-nav__sublabel">Newer Post</div><div class="pagination-nav__label">[오브젝트] Chapter03. 역할, 책임, 협력.</div></a><a class="pagination-nav__link pagination-nav__link--next" href="/dev-blog/object/chapter/01"><div class="pagination-nav__sublabel">Older Post</div><div class="pagination-nav__label">[오브젝트] Chapter01. 객체, 설계.</div></a></nav><div></div></main><div class="col col--2"><div class="tableOfContents_bqdL thin-scrollbar"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#요구사항-확인" class="table-of-contents__link toc-highlight">요구사항 확인</a></li><li><a href="#협력-객체-클래스" class="table-of-contents__link toc-highlight">협력, 객체, 클래스</a></li><li><a href="#도메인의-구조를-따르는-프로그램-구조" class="table-of-contents__link toc-highlight">도메인의 구조를 따르는 프로그램 구조</a><ul><li><a href="#도메인" class="table-of-contents__link toc-highlight">도메인?</a></li></ul></li><li><a href="#클래스-구현" class="table-of-contents__link toc-highlight">클래스 구현</a><ul><li><a href="#자율적인-객체" class="table-of-contents__link toc-highlight">자율적인 객체</a></li><li><a href="#프로그래머의-자유" class="table-of-contents__link toc-highlight">프로그래머의 자유</a></li></ul></li><li><a href="#협력하는-객체들의-공동체" class="table-of-contents__link toc-highlight">협력하는 객체들의 공동체</a></li><li><a href="#추상화---상속과-다형성" class="table-of-contents__link toc-highlight">추상화 - 상속과 다형성</a><ul><li><a href="#컴파일-시간-의존성과-실행시간-의존성" class="table-of-contents__link toc-highlight">컴파일 시간 의존성과 실행시간 의존성</a></li><li><a href="#차이에-의한-프로그래밍" class="table-of-contents__link toc-highlight">차이에 의한 프로그래밍</a></li><li><a href="#다형성" class="table-of-contents__link toc-highlight">다형성</a></li><li><a href="#인터페이스와-다형성" class="table-of-contents__link toc-highlight">인터페이스와 다형성</a></li></ul></li><li><a href="#추상화와-유연성" class="table-of-contents__link toc-highlight">추상화와 유연성</a><ul><li><a href="#추상화의-힘" class="table-of-contents__link toc-highlight">추상화의 힘</a></li><li><a href="#유연한-설계" class="table-of-contents__link toc-highlight">유연한 설계</a></li><li><a href="#추상-클래스와-인터페이스-트레이드-오프" class="table-of-contents__link toc-highlight">추상 클래스와 인터페이스 트레이드 오프</a></li><li><a href="#코드-재사용" class="table-of-contents__link toc-highlight">코드 재사용</a></li><li><a href="#상속" class="table-of-contents__link toc-highlight">상속</a></li><li><a href="#합성" class="table-of-contents__link toc-highlight">합성</a></li></ul></li></ul></div></div></div></div></div><footer class="footer footer--dark"><div class="container container-fluid"><div class="footer__bottom text--center"><div class="footer__copyright">Copyright © 2023 Jeonghun Kong. Built with Docusaurus.</div></div></div></footer></div>
<script src="/assets/js/runtime~main.989dd6bd.js"></script>
<script src="/assets/js/main.044671ee.js"></script>
</body>
</html>